# 温度测量算法设计文档

## 文档信息

| 项目 | 内容 |
|------|------|
| 产品名称 | Ultra-TM02 超低温温度测量模块 |
| 文档类型 | 算法设计 |
| 版本 | V1.0 |
| 创建日期 | 2025年12月18日 |

---

## 一、测量原理

### 1.1 二极管温度测量原理

二极管的正向电压与温度呈现近似线性的负温度系数关系。当恒定电流流过二极管时，正向电压随温度变化而变化。

**基本公式：**
```
Vf = (kT/q) × ln(I/Is) + Rs × I

其中：
- Vf: 正向电压
- k: 玻尔兹曼常数 (1.38×10⁻²³ J/K)
- T: 绝对温度 (K)
- q: 电子电荷 (1.6×10⁻¹⁹ C)
- I: 正向电流
- Is: 反向饱和电流
- Rs: 串联电阻
```

### 1.2 温度系数

| 温度范围 | 典型温度系数 |
|----------|--------------|
| 300K (27℃) | -2.0 mV/K |
| 77K (-196℃) | -2.2 mV/K |
| 4K (-269℃) | -2.5 mV/K |

### 1.3 测量方式

本模块采用**四线制差分测量**：

```
        恒流源 (10μA/17μA)
             │
     I+ ────┬────┐
             │     │
            ┌┴┐    │
  V+ ──────┤D │────┼────── V-
            └┬┘    │
     I- ────┴────┘
```

**四线制优点：**
- 消除引线电阻影响
- 提高测量精度
- 适合长距离传输

---

## 二、信号采集

### 2.1 ADC配置

| 参数 | 配置 |
|------|------|
| ADC类型 | 24位Sigma-Delta |
| 参考电压 | 6.5V (来自6.5VA电源轨) |
| 输入方式 | 差分输入 |
| 采样率 | 1 SPS |
| 增益 | 可编程 (1/2/4/8/16/32/64/128) |

> **注意**：参考电压值需根据实际硬件测量TP4 (6.5VA)确认。如测量值与6.5V有偏差，需在代码中调整ADC_VREF宏定义。

### 2.2 信号范围

| 温度范围 | 电压范围 (10μA) | 电压范围 (17μA) |
|----------|------------------|------------------|
| 1.4K | ~1.6V | ~2.7V |
| 77K | ~1.0V | ~1.7V |
| 300K | ~0.5V | ~0.85V |
| 500K | ~0.3V | ~0.5V |

### 2.3 ADC读取代码

```c
// svc_adc.c

#include "svc_adc.h"
#include "bsp_spi.h"
#include "bsp_gpio.h"

// ADC寄存器定义
#define ADC_REG_STATUS      0x00
#define ADC_REG_CONFIG      0x01
#define ADC_REG_DATA        0x02

// 参考电压
#define ADC_VREF            6.5f
// ADC满量程
#define ADC_FULLSCALE       16777216.0f  // 2^24

static float adc_gain = 1.0f;

/**
 * @brief  ADC初始化
 */
void SVC_ADC_Init(void)
{
    // 配置ADC
    // 设置采样率、增益等
    uint8_t config[3];
    
    config[0] = 0x00;  // 配置寄存器地址
    config[1] = 0x04;  // 增益=1, 采样率=1SPS
    config[2] = 0x00;  // 其他配置
    
    BSP_ADC_CS(0);
    BSP_SPI_Transmit(config, 3);
    BSP_ADC_CS(1);
    
    adc_gain = 1.0f;
}

/**
 * @brief  读取ADC原始值
 * @retval 24位ADC原始值
 */
uint32_t SVC_ADC_ReadRaw(void)
{
    uint8_t rx_buf[3];
    uint32_t raw_value;
    
    // 等待转换完成
    while (!SVC_ADC_IsReady());
    
    // 读取数据寄存器
    BSP_ADC_CS(0);
    BSP_SPI_TransmitReceive(ADC_REG_DATA | 0x40);  // 读命令
    rx_buf[0] = BSP_SPI_TransmitReceive(0x00);
    rx_buf[1] = BSP_SPI_TransmitReceive(0x00);
    rx_buf[2] = BSP_SPI_TransmitReceive(0x00);
    BSP_ADC_CS(1);
    
    // 组合24位数据 (MSB first)
    raw_value = ((uint32_t)rx_buf[0] << 16) | 
                ((uint32_t)rx_buf[1] << 8) | 
                rx_buf[2];
    
    return raw_value;
}

/**
 * @brief  读取ADC电压值
 * @retval 电压值 (mV)
 */
float SVC_ADC_ReadVoltage(void)
{
    uint32_t raw = SVC_ADC_ReadRaw();
    float voltage;
    
    // 转换为电压
    // 假设差分输入，中点为Vref/2
    int32_t signed_raw = (int32_t)(raw - 0x800000);
    voltage = (float)signed_raw / ADC_FULLSCALE * ADC_VREF * 1000.0f / adc_gain;
    
    return voltage;  // 单位: mV
}

/**
 * @brief  检查ADC是否准备好
 * @retval 1=准备好, 0=忙
 */
uint8_t SVC_ADC_IsReady(void)
{
    // 读取DRDY引脚状态
    return (HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_0) == GPIO_PIN_RESET);
}

/**
 * @brief  设置ADC增益
 * @param  gain: 增益值 (1/2/4/8/16/32/64/128)
 */
void SVC_ADC_SetGain(uint8_t gain)
{
    uint8_t config[2];
    uint8_t gain_bits;
    
    switch (gain)
    {
        case 1:   gain_bits = 0x00; adc_gain = 1.0f; break;
        case 2:   gain_bits = 0x01; adc_gain = 2.0f; break;
        case 4:   gain_bits = 0x02; adc_gain = 4.0f; break;
        case 8:   gain_bits = 0x03; adc_gain = 8.0f; break;
        case 16:  gain_bits = 0x04; adc_gain = 16.0f; break;
        case 32:  gain_bits = 0x05; adc_gain = 32.0f; break;
        case 64:  gain_bits = 0x06; adc_gain = 64.0f; break;
        case 128: gain_bits = 0x07; adc_gain = 128.0f; break;
        default:  gain_bits = 0x00; adc_gain = 1.0f; break;
    }
    
    config[0] = ADC_REG_CONFIG;
    config[1] = gain_bits;
    
    BSP_ADC_CS(0);
    BSP_SPI_Transmit(config, 2);
    BSP_ADC_CS(1);
}
```

---

## 三、数字滤波

### 3.1 滤波策略

为提高测量稳定性，采用多级滤波：

```
┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐
│ ADC原始值 │───→│ 中值滤波  │───→│ 均值滤波  │───→│ 滑动平均  │───→ 输出
└──────────┘    └──────────┘    └──────────┘    └──────────┘
```

### 3.2 中值滤波

消除突发噪声和异常值：

```c
/**
 * @brief  中值滤波 (5点)
 * @param  data: 数据数组
 * @param  len: 数据长度 (需要>=5)
 * @retval 中值
 */
float MedianFilter(float *data, uint8_t len)
{
    float temp[5];
    float t;
    
    // 复制数据
    for (int i = 0; i < 5; i++)
        temp[i] = data[i];
    
    // 冒泡排序
    for (int i = 0; i < 4; i++)
    {
        for (int j = 0; j < 4 - i; j++)
        {
            if (temp[j] > temp[j + 1])
            {
                t = temp[j];
                temp[j] = temp[j + 1];
                temp[j + 1] = t;
            }
        }
    }
    
    // 返回中值
    return temp[2];
}
```

### 3.3 均值滤波

去除高频噪声：

```c
/**
 * @brief  均值滤波
 * @param  data: 数据数组
 * @param  len: 数据长度
 * @retval 均值
 */
float AverageFilter(float *data, uint8_t len)
{
    float sum = 0;
    
    for (int i = 0; i < len; i++)
        sum += data[i];
    
    return sum / len;
}
```

### 3.4 滑动平均滤波

平滑输出，减少抖动：

```c
// 滑动平均滤波器
typedef struct {
    float buffer[16];   // 缓冲区
    uint8_t index;      // 当前索引
    uint8_t count;      // 有效数据数
    float sum;          // 累加和
} MovingAvgFilter_t;

/**
 * @brief  滑动平均滤波初始化
 * @param  filter: 滤波器结构体
 */
void MovingAvgFilter_Init(MovingAvgFilter_t *filter)
{
    memset(filter->buffer, 0, sizeof(filter->buffer));
    filter->index = 0;
    filter->count = 0;
    filter->sum = 0;
}

/**
 * @brief  添加数据并获取滤波结果
 * @param  filter: 滤波器结构体
 * @param  value: 新数据
 * @retval 滤波后的值
 */
float MovingAvgFilter_Update(MovingAvgFilter_t *filter, float value)
{
    // 减去旧值
    filter->sum -= filter->buffer[filter->index];
    
    // 添加新值
    filter->buffer[filter->index] = value;
    filter->sum += value;
    
    // 更新索引
    filter->index = (filter->index + 1) & 0x0F;  // 取模16
    
    // 更新计数
    if (filter->count < 16)
        filter->count++;
    
    // 返回平均值
    return filter->sum / filter->count;
}
```

---

## 四、分度表查表

### 4.1 分度表格式

分度表存储在Flash中，格式如下：

```c
// 分度表数据点
typedef struct {
    float voltage;      // 电压值 (mV)
    float temperature;  // 温度值 (K)
} TablePoint_t;

// 分度表结构
typedef struct {
    uint32_t magic;             // 魔数 "TBL\0"
    uint16_t point_count;       // 数据点数
    uint16_t reserved;          // 保留
    TablePoint_t points[4871];  // 数据点数组
    uint16_t crc;               // CRC校验
} TempTable_t;
```

### 4.2 线性插值算法

```c
// 分度表指针 (指向Flash)
static TempTable_t *p_table = (TempTable_t*)0x08040000;

/**
 * @brief  根据电压查表获取温度
 * @param  voltage: 电压值 (mV)
 * @retval 温度值 (K)
 */
float TempTable_Lookup(float voltage)
{
    int low = 0;
    int high = p_table->point_count - 1;
    int mid;
    
    // 边界检查
    if (voltage >= p_table->points[0].voltage)
        return p_table->points[0].temperature;
    
    if (voltage <= p_table->points[high].voltage)
        return p_table->points[high].temperature;
    
    // 二分查找
    while (high - low > 1)
    {
        mid = (low + high) / 2;
        
        if (voltage > p_table->points[mid].voltage)
            high = mid;
        else
            low = mid;
    }
    
    // 线性插值
    float v0 = p_table->points[low].voltage;
    float v1 = p_table->points[high].voltage;
    float t0 = p_table->points[low].temperature;
    float t1 = p_table->points[high].temperature;
    
    float temp = t0 + (voltage - v0) * (t1 - t0) / (v1 - v0);
    
    return temp;
}

/**
 * @brief  检查分度表有效性
 * @retval 0=有效, -1=无效
 */
int TempTable_Verify(void)
{
    // 检查魔数
    if (p_table->magic != 0x004C4254)  // "TBL\0"
        return -1;
    
    // 检查点数
    if (p_table->point_count == 0 || p_table->point_count > 4871)
        return -1;
    
    // 检查CRC (可选)
    // ...
    
    return 0;
}
```

### 4.3 温度单位转换

```c
/**
 * @brief  开尔文转摄氏度
 * @param  kelvin: 温度 (K)
 * @retval 温度 (℃)
 */
float Kelvin_to_Celsius(float kelvin)
{
    return kelvin - 273.15f;
}

/**
 * @brief  摄氏度转开尔文
 * @param  celsius: 温度 (℃)
 * @retval 温度 (K)
 */
float Celsius_to_Kelvin(float celsius)
{
    return celsius + 273.15f;
}
```

---

## 五、温度测量主流程

### 5.1 测量状态机

```c
// 测量状态
typedef enum {
    TEMP_STATE_IDLE,        // 空闲
    TEMP_STATE_CONVERT,     // 转换中
    TEMP_STATE_READ,        // 读取
    TEMP_STATE_CALC,        // 计算
    TEMP_STATE_OUTPUT       // 输出
} TempState_t;

// 测量结构体
typedef struct {
    TempState_t state;      // 状态
    uint8_t current_src;    // 电流源 (0:10μA, 1:17μA)
    float raw_voltage;      // 原始电压 (mV)
    float filtered_voltage; // 滤波后电压 (mV)
    float temperature_K;    // 温度 (K)
    float temperature_C;    // 温度 (℃)
    uint8_t running;        // 运行标志
} TempMeasure_t;

static TempMeasure_t g_temp;
static MovingAvgFilter_t g_filter;
```

### 5.2 测量流程实现

```c
// app_temp.c

#include "app_temp.h"
#include "svc_adc.h"
#include "svc_dac.h"
#include "svc_lcd.h"

// 采样缓冲
#define SAMPLE_COUNT    5
static float sample_buffer[SAMPLE_COUNT];
static uint8_t sample_index = 0;

/**
 * @brief  温度测量初始化
 */
void APP_Temp_Init(void)
{
    g_temp.state = TEMP_STATE_IDLE;
    g_temp.current_src = 0;  // 默认10μA
    g_temp.raw_voltage = 0;
    g_temp.filtered_voltage = 0;
    g_temp.temperature_K = 0;
    g_temp.temperature_C = 0;
    g_temp.running = 0;
    
    MovingAvgFilter_Init(&g_filter);
    
    // 初始化ADC
    SVC_ADC_Init();
    
    // 初始化DAC (设置电流源)
    SVC_DAC_Init();
    SVC_DAC_SetCurrentSource(CURRENT_SRC_10UA);
}

/**
 * @brief  开始测量
 */
void APP_Temp_Start(void)
{
    g_temp.running = 1;
    g_temp.state = TEMP_STATE_CONVERT;
    sample_index = 0;
}

/**
 * @brief  停止测量
 */
void APP_Temp_Stop(void)
{
    g_temp.running = 0;
    g_temp.state = TEMP_STATE_IDLE;
}

/**
 * @brief  设置电流源
 * @param  src: 0=10μA, 1=17μA
 */
void APP_Temp_SetCurrentSource(uint8_t src)
{
    g_temp.current_src = src;
    SVC_DAC_SetCurrentSource(src ? CURRENT_SRC_17UA : CURRENT_SRC_10UA);
}

/**
 * @brief  获取温度值
 * @retval 温度 (℃)
 */
float APP_Temp_GetValue(void)
{
    return g_temp.temperature_C;
}

/**
 * @brief  获取电压值
 * @retval 电压 (mV)
 */
float APP_Temp_GetVoltage(void)
{
    return g_temp.filtered_voltage;
}

/**
 * @brief  温度测量处理 (周期调用)
 */
void APP_Temp_Process(void)
{
    if (!g_temp.running)
        return;
    
    switch (g_temp.state)
    {
        case TEMP_STATE_CONVERT:
            // 等待ADC转换完成
            if (SVC_ADC_IsReady())
            {
                g_temp.state = TEMP_STATE_READ;
            }
            break;
            
        case TEMP_STATE_READ:
            // 读取ADC值
            g_temp.raw_voltage = SVC_ADC_ReadVoltage();
            
            // 存入缓冲
            sample_buffer[sample_index++] = g_temp.raw_voltage;
            
            if (sample_index >= SAMPLE_COUNT)
            {
                sample_index = 0;
                g_temp.state = TEMP_STATE_CALC;
            }
            else
            {
                g_temp.state = TEMP_STATE_CONVERT;
            }
            break;
            
        case TEMP_STATE_CALC:
        {
            // 中值滤波
            float median = MedianFilter(sample_buffer, SAMPLE_COUNT);
            
            // 滑动平均滤波
            g_temp.filtered_voltage = MovingAvgFilter_Update(&g_filter, median);
            
            // 查分度表
            g_temp.temperature_K = TempTable_Lookup(g_temp.filtered_voltage);
            
            // 单位转换
            g_temp.temperature_C = Kelvin_to_Celsius(g_temp.temperature_K);
            
            g_temp.state = TEMP_STATE_OUTPUT;
        }
            break;
            
        case TEMP_STATE_OUTPUT:
            // 更新4-20mA输出
            APP_Output_UpdateCurrent(g_temp.temperature_C);
            
            // 继续下一轮测量
            g_temp.state = TEMP_STATE_CONVERT;
            break;
            
        default:
            g_temp.state = TEMP_STATE_IDLE;
            break;
    }
}
```

---

## 六、4-20mA输出

### 6.1 输出转换

```c
// app_output.c

#include "app_output.h"
#include "svc_dac.h"
#include "app_param.h"

// 输出配置
static struct {
    float temp_4mA;     // 4mA对应温度
    float temp_20mA;    // 20mA对应温度
    float current;      // 当前输出电流
} g_output;

/**
 * @brief  输出初始化
 */
void APP_Output_Init(void)
{
    // 从参数加载
    g_output.temp_4mA = APP_Param_Get4mATemp();
    g_output.temp_20mA = APP_Param_Get20mATemp();
    g_output.current = 4.0f;
}

/**
 * @brief  根据温度更新输出电流
 * @param  temperature: 温度值 (℃)
 */
void APP_Output_UpdateCurrent(float temperature)
{
    float current;
    
    // 线性映射
    if (g_output.temp_20mA != g_output.temp_4mA)
    {
        current = 4.0f + (temperature - g_output.temp_4mA) * 16.0f / 
                  (g_output.temp_20mA - g_output.temp_4mA);
    }
    else
    {
        current = 12.0f;  // 中间值
    }
    
    // 限幅
    if (current < 4.0f) current = 4.0f;
    if (current > 20.0f) current = 20.0f;
    
    g_output.current = current;
    
    // 设置DAC输出
    SVC_DAC_Set420mA(current);
}

/**
 * @brief  获取当前输出电流
 * @retval 电流值 (mA)
 */
float APP_Output_GetCurrent(void)
{
    return g_output.current;
}

/**
 * @brief  设置4mA温度点
 * @param  temp: 温度 (℃)
 */
void APP_Output_Set4mATemp(float temp)
{
    g_output.temp_4mA = temp;
}

/**
 * @brief  设置20mA温度点
 * @param  temp: 温度 (℃)
 */
void APP_Output_Set20mATemp(float temp)
{
    g_output.temp_20mA = temp;
}
```

### 6.2 DAC输出控制

```c
// svc_dac.c

#include "svc_dac.h"
#include "bsp_spi.h"
#include "bsp_gpio.h"

// DAC满量程
#define DAC_FULLSCALE   65536.0f  // 16位DAC
// 参考电压
#define DAC_VREF        6.5f

// V/I转换系数 (mA/V)
#define VI_COEFFICIENT  2.5f  // 根据实际电路确定

/**
 * @brief  DAC初始化
 */
void SVC_DAC_Init(void)
{
    // 初始化DAC1 (电流源)
    // 初始化DAC2 (4-20mA)
}

/**
 * @brief  设置电流源
 * @param  src: CURRENT_SRC_10UA 或 CURRENT_SRC_17UA
 */
void SVC_DAC_SetCurrentSource(CurrentSource_e src)
{
    uint16_t dac_value;
    
    if (src == CURRENT_SRC_10UA)
    {
        // 设置10μA输出
        dac_value = (uint16_t)(10.0e-6f / VI_COEFFICIENT * DAC_FULLSCALE / DAC_VREF);
    }
    else
    {
        // 设置17μA输出
        dac_value = (uint16_t)(17.0e-6f / VI_COEFFICIENT * DAC_FULLSCALE / DAC_VREF);
    }
    
    // 写入DAC1
    SVC_DAC_WriteRaw(1, dac_value);
}

/**
 * @brief  设置4-20mA输出
 * @param  current_mA: 电流值 (mA)
 */
void SVC_DAC_Set420mA(float current_mA)
{
    // 电流限幅
    if (current_mA < 4.0f) current_mA = 4.0f;
    if (current_mA > 20.0f) current_mA = 20.0f;
    
    // 计算DAC值
    // 根据V/I电路设计确定转换关系
    float voltage = current_mA / VI_COEFFICIENT;
    uint16_t dac_value = (uint16_t)(voltage / DAC_VREF * DAC_FULLSCALE);
    
    // 写入DAC2
    SVC_DAC_WriteRaw(2, dac_value);
}

/**
 * @brief  写入DAC原始值
 * @param  channel: 通道 (1或2)
 * @param  value: 16位DAC值
 */
void SVC_DAC_WriteRaw(uint8_t channel, uint16_t value)
{
    uint8_t buf[3];
    
    buf[0] = 0x00;  // 写命令
    buf[1] = (value >> 8) & 0xFF;
    buf[2] = value & 0xFF;
    
    if (channel == 1)
    {
        BSP_DAC1_CS(0);
        BSP_SPI_Transmit(buf, 3);
        BSP_DAC1_CS(1);
        
        // 加载DAC
        BSP_DAC1_LOAD(0);
        HAL_Delay(1);
        BSP_DAC1_LOAD(1);
    }
    else
    {
        BSP_DAC2_CS(0);
        BSP_SPI_Transmit(buf, 3);
        BSP_DAC2_CS(1);
        
        // 加载DAC
        BSP_DAC2_LOAD(0);
        HAL_Delay(1);
        BSP_DAC2_LOAD(1);
    }
}
```

---

## 七、误差分析

### 7.1 误差来源

| 误差类型 | 来源 | 典型值 |
|----------|------|--------|
| ADC量化误差 | 24位ADC | < 0.001% |
| 参考电压漂移 | 基准芯片 | < 0.05% |
| 电流源误差 | DAC + V/I | < 0.05% |
| 分度表误差 | 插值计算 | < 0.01K |
| 噪声误差 | 环境干扰 | < 0.01K |

### 7.2 精度保证措施

1. **高精度参考电压**：使用0.05%精度基准
2. **多级滤波**：消除噪声影响
3. **差分输入**：消除共模干扰
4. **四线制测量**：消除引线电阻
5. **隔离设计**：减少地环路干扰

---

*文档版本：V1.0*
*创建日期：2025年12月18日*

