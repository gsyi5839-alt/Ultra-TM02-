# 通讯协议详细设计文档

## 文档信息

| 项目 | 内容 |
|------|------|
| 产品名称 | Ultra-TM02 超低温温度测量模块 |
| 文档类型 | 通讯协议设计 |
| 版本 | V1.0 |
| 创建日期 | 2025年12月18日 |

---

## 一、通讯概述

### 1.1 通讯接口

| 接口 | 类型 | 用途 |
|------|------|------|
| USB | CDC虚拟串口 | 上位机软件通讯 |
| USART6 | TTL串口 | LCD串口屏通讯 |

### 1.2 通讯参数

| 参数 | USB CDC | USART6 |
|------|---------|--------|
| 波特率 | 115200 | 115200 |
| 数据位 | 8 | 8 |
| 停止位 | 1 | 1 |
| 校验 | 无 | 无 |
| 流控 | 无 | 无 |

---

## 二、USB通讯协议

### 2.1 帧格式

```
┌──────┬──────┬──────┬──────────────┬──────┬──────┐
│ 帧头 │ 命令 │ 长度 │    数据      │ CRC  │ 帧尾 │
│ 0xAA │ CMD  │ LEN  │   DATA[N]    │ CRC16│ 0x55 │
│ 1字节│ 1字节│ 1字节│   N字节      │ 2字节│ 1字节│
└──────┴──────┴──────┴──────────────┴──────┴──────┘
```

### 2.2 字段说明

| 字段 | 长度 | 说明 |
|------|------|------|
| 帧头 | 1字节 | 固定0xAA |
| 命令 | 1字节 | 命令码 |
| 长度 | 1字节 | 数据域长度 (0-255) |
| 数据 | N字节 | 命令参数数据 |
| CRC | 2字节 | CRC16校验 (低字节在前) |
| 帧尾 | 1字节 | 固定0x55 |

### 2.3 CRC16计算

```c
/**
 * @brief  CRC16计算 (CCITT)
 * @param  data: 数据指针
 * @param  len: 数据长度
 * @retval CRC16值
 */
uint16_t CRC16_Calculate(uint8_t *data, uint16_t len)
{
    uint16_t crc = 0xFFFF;
    
    while (len--)
    {
        crc ^= *data++;
        for (int i = 0; i < 8; i++)
        {
            if (crc & 0x0001)
                crc = (crc >> 1) ^ 0xA001;
            else
                crc >>= 1;
        }
    }
    return crc;
}
```

---

## 三、命令定义

### 3.1 命令列表

| 命令码 | 名称 | 方向 | 描述 |
|--------|------|------|------|
| 0x01 | GET_DEVICE_ID | 主机→设备 | 获取设备ID |
| 0x02 | GET_TEMPERATURE | 主机→设备 | 获取温度值 |
| 0x03 | GET_VOLTAGE | 主机→设备 | 获取电压值 |
| 0x04 | GET_CURRENT | 主机→设备 | 获取输出电流 |
| 0x05 | GET_STATUS | 主机→设备 | 获取设备状态 |
| 0x10 | SET_CURRENT_SRC | 主机→设备 | 设置电流源 |
| 0x11 | SET_CURRENT_ADJ_10UA | 主机→设备 | 设置10μA调整值 |
| 0x12 | SET_CURRENT_ADJ_17UA | 主机→设备 | 设置17μA调整值 |
| 0x20 | SET_4MA_TEMP | 主机→设备 | 设置4mA温度点 |
| 0x21 | SET_20MA_TEMP | 主机→设备 | 设置20mA温度点 |
| 0x30 | START_ACQ | 主机→设备 | 开始采集 |
| 0x31 | STOP_ACQ | 主机→设备 | 停止采集 |
| 0x40 | LOAD_TABLE_START | 主机→设备 | 分度表下载开始 |
| 0x41 | LOAD_TABLE_DATA | 主机→设备 | 分度表数据包 |
| 0x42 | LOAD_TABLE_END | 主机→设备 | 分度表下载结束 |
| 0x50 | SAVE_PARAM | 主机→设备 | 保存参数 |
| 0x51 | LOAD_PARAM | 主机→设备 | 加载参数 |
| 0x52 | RESET_DEFAULT | 主机→设备 | 恢复默认 |
| 0x80 | ACK | 设备→主机 | 确认响应 |
| 0x81 | NACK | 设备→主机 | 否定响应 |
| 0xF0 | DATA_REPORT | 设备→主机 | 数据主动上报 |

### 3.2 响应状态码

| 状态码 | 说明 |
|--------|------|
| 0x00 | 成功 |
| 0x01 | 命令无效 |
| 0x02 | 参数错误 |
| 0x03 | CRC错误 |
| 0x04 | 忙 |
| 0x05 | Flash写入失败 |
| 0x06 | 分度表错误 |

---

## 四、命令详细说明

### 4.1 获取设备ID (0x01)

**请求帧：**
```
AA 01 00 [CRC_L] [CRC_H] 55
```

**响应帧：**
```
AA 01 10 [16字节设备ID] [CRC_L] [CRC_H] 55
```

**设备ID格式：**
```
TM02-XXXXXXXX (16字节ASCII)
```

---

### 4.2 获取温度值 (0x02)

**请求帧：**
```
AA 02 00 [CRC_L] [CRC_H] 55
```

**响应帧：**
```
AA 02 04 [温度值float, 4字节] [CRC_L] [CRC_H] 55
```

**温度值格式：**
- 4字节IEEE754单精度浮点数
- 低字节在前 (Little-Endian)
- 单位：℃

**示例：**
```
温度 = 25.123℃
float值: 0x41C8FBE7
响应: AA 02 04 E7 FB C8 41 [CRC] 55
```

---

### 4.3 获取电压值 (0x03)

**请求帧：**
```
AA 03 00 [CRC_L] [CRC_H] 55
```

**响应帧：**
```
AA 03 04 [电压值float, 4字节] [CRC_L] [CRC_H] 55
```

**电压值格式：**
- 单位：mV
- 二极管正向压降

---

### 4.4 获取输出电流 (0x04)

**请求帧：**
```
AA 04 00 [CRC_L] [CRC_H] 55
```

**响应帧：**
```
AA 04 04 [电流值float, 4字节] [CRC_L] [CRC_H] 55
```

**电流值格式：**
- 单位：mA
- 范围：4.00~20.00 mA

---

### 4.5 获取设备状态 (0x05)

**请求帧：**
```
AA 05 00 [CRC_L] [CRC_H] 55
```

**响应帧：**
```
AA 05 08 [状态数据, 8字节] [CRC_L] [CRC_H] 55
```

**状态数据格式：**
| 偏移 | 长度 | 说明 |
|------|------|------|
| 0 | 1字节 | 运行状态 (0:停止, 1:采集中) |
| 1 | 1字节 | 电流源选择 (0:10μA, 1:17μA) |
| 2 | 1字节 | 探头状态 (0:正常, 1:断开, 2:短路) |
| 3 | 1字节 | 保留 |
| 4 | 4字节 | 采集计数 |

---

### 4.6 设置电流源 (0x10)

**请求帧：**
```
AA 10 01 [电流源] [CRC_L] [CRC_H] 55
```

**参数：**
| 值 | 说明 |
|-----|------|
| 0x00 | 10μA电流源 |
| 0x01 | 17μA电流源 |

**响应帧：**
```
AA 80 01 [状态码] [CRC_L] [CRC_H] 55
```

---

### 4.7 设置10μA调整值 (0x11)

**请求帧：**
```
AA 11 04 [调整值float, 4字节] [CRC_L] [CRC_H] 55
```

**参数：**
- 调整值单位：μA
- 范围：-1.0 ~ +1.0 μA

**响应帧：**
```
AA 80 01 [状态码] [CRC_L] [CRC_H] 55
```

---

### 4.8 设置17μA调整值 (0x12)

**请求帧：**
```
AA 12 04 [调整值float, 4字节] [CRC_L] [CRC_H] 55
```

**参数：**
- 调整值单位：μA
- 范围：-1.0 ~ +1.0 μA

**响应帧：**
```
AA 80 01 [状态码] [CRC_L] [CRC_H] 55
```

---

### 4.9 设置4mA温度点 (0x20)

**请求帧：**
```
AA 20 04 [温度值float, 4字节] [CRC_L] [CRC_H] 55
```

**参数：**
- 温度单位：℃
- 表示4mA输出对应的温度值

**响应帧：**
```
AA 80 01 [状态码] [CRC_L] [CRC_H] 55
```

---

### 4.10 设置20mA温度点 (0x21)

**请求帧：**
```
AA 21 04 [温度值float, 4字节] [CRC_L] [CRC_H] 55
```

**参数：**
- 温度单位：℃
- 表示20mA输出对应的温度值

**响应帧：**
```
AA 80 01 [状态码] [CRC_L] [CRC_H] 55
```

---

### 4.11 开始采集 (0x30)

**请求帧：**
```
AA 30 00 [CRC_L] [CRC_H] 55
```

**响应帧：**
```
AA 80 01 [状态码] [CRC_L] [CRC_H] 55
```

**说明：**
- 开始采集后，设备以1Hz频率采集温度
- 可通过主动上报或轮询获取数据

---

### 4.12 停止采集 (0x31)

**请求帧：**
```
AA 31 00 [CRC_L] [CRC_H] 55
```

**响应帧：**
```
AA 80 01 [状态码] [CRC_L] [CRC_H] 55
```

---

### 4.13 分度表下载开始 (0x40)

**请求帧：**
```
AA 40 04 [总点数uint16] [总包数uint16] [CRC_L] [CRC_H] 55
```

**参数：**
| 偏移 | 长度 | 说明 |
|------|------|------|
| 0 | 2字节 | 分度表点数 (最大4871) |
| 2 | 2字节 | 数据包总数 |

**响应帧：**
```
AA 80 01 [状态码] [CRC_L] [CRC_H] 55
```

---

### 4.14 分度表数据包 (0x41)

**请求帧：**
```
AA 41 [LEN] [包序号uint16] [数据...] [CRC_L] [CRC_H] 55
```

**数据格式：**
- 每个数据点：电压(4字节float) + 温度(4字节float) = 8字节
- 每包最多传输32个点 (256字节)

**响应帧：**
```
AA 80 01 [状态码] [CRC_L] [CRC_H] 55
```

---

### 4.15 分度表下载结束 (0x42)

**请求帧：**
```
AA 42 02 [CRC校验uint16] [CRC_L] [CRC_H] 55
```

**参数：**
- 整个分度表数据的CRC16校验值

**响应帧：**
```
AA 80 01 [状态码] [CRC_L] [CRC_H] 55
```

---

### 4.16 保存参数 (0x50)

**请求帧：**
```
AA 50 00 [CRC_L] [CRC_H] 55
```

**响应帧：**
```
AA 80 01 [状态码] [CRC_L] [CRC_H] 55
```

**说明：**
- 将当前参数保存到内部Flash
- 包括：电流源选择、调整值、4-20mA温度点

---

### 4.17 数据主动上报 (0xF0)

**上报帧（设备→主机）：**
```
AA F0 0C [数据, 12字节] [CRC_L] [CRC_H] 55
```

**数据格式：**
| 偏移 | 长度 | 说明 |
|------|------|------|
| 0 | 4字节 | 温度值 (float, ℃) |
| 4 | 4字节 | 电压值 (float, mV) |
| 8 | 4字节 | 输出电流 (float, mA) |

---

## 五、通讯实现代码

### 5.1 协议定义

```c
// protocol.h

#ifndef __PROTOCOL_H
#define __PROTOCOL_H

#include <stdint.h>

// 帧定义
#define FRAME_HEAD          0xAA
#define FRAME_TAIL          0x55
#define MAX_DATA_LEN        256

// 命令码定义
#define CMD_GET_DEVICE_ID       0x01
#define CMD_GET_TEMPERATURE     0x02
#define CMD_GET_VOLTAGE         0x03
#define CMD_GET_CURRENT         0x04
#define CMD_GET_STATUS          0x05
#define CMD_SET_CURRENT_SRC     0x10
#define CMD_SET_CURRENT_ADJ_10  0x11
#define CMD_SET_CURRENT_ADJ_17  0x12
#define CMD_SET_4MA_TEMP        0x20
#define CMD_SET_20MA_TEMP       0x21
#define CMD_START_ACQ           0x30
#define CMD_STOP_ACQ            0x31
#define CMD_LOAD_TABLE_START    0x40
#define CMD_LOAD_TABLE_DATA     0x41
#define CMD_LOAD_TABLE_END      0x42
#define CMD_SAVE_PARAM          0x50
#define CMD_LOAD_PARAM          0x51
#define CMD_RESET_DEFAULT       0x52
#define CMD_ACK                 0x80
#define CMD_NACK                0x81
#define CMD_DATA_REPORT         0xF0

// 状态码定义
#define STATUS_OK               0x00
#define STATUS_INVALID_CMD      0x01
#define STATUS_INVALID_PARAM    0x02
#define STATUS_CRC_ERROR        0x03
#define STATUS_BUSY             0x04
#define STATUS_FLASH_ERROR      0x05
#define STATUS_TABLE_ERROR      0x06

// 帧结构
typedef struct {
    uint8_t head;           // 帧头
    uint8_t cmd;            // 命令码
    uint8_t len;            // 数据长度
    uint8_t data[MAX_DATA_LEN];  // 数据
    uint16_t crc;           // CRC校验
    uint8_t tail;           // 帧尾
} Frame_t;

// 协议接口
void Protocol_Init(void);
void Protocol_Process(uint8_t *data, uint16_t len);
void Protocol_SendAck(uint8_t cmd, uint8_t status);
void Protocol_SendData(uint8_t cmd, uint8_t *data, uint8_t len);
void Protocol_ReportData(float temp, float voltage, float current);

#endif
```

### 5.2 协议处理

```c
// protocol.c

#include "protocol.h"
#include "app_temp.h"
#include "app_param.h"
#include "usbd_cdc_if.h"
#include <string.h>

// 接收缓冲区
static uint8_t rx_buf[512];
static uint16_t rx_index = 0;

// 解析状态
typedef enum {
    PARSE_HEAD,
    PARSE_CMD,
    PARSE_LEN,
    PARSE_DATA,
    PARSE_CRC_L,
    PARSE_CRC_H,
    PARSE_TAIL
} ParseState_t;

static ParseState_t parse_state = PARSE_HEAD;
static Frame_t rx_frame;
static uint16_t data_index = 0;

/**
 * @brief  协议初始化
 */
void Protocol_Init(void)
{
    rx_index = 0;
    parse_state = PARSE_HEAD;
}

/**
 * @brief  发送确认响应
 * @param  cmd: 原命令
 * @param  status: 状态码
 */
void Protocol_SendAck(uint8_t cmd, uint8_t status)
{
    uint8_t buf[8];
    uint16_t crc;
    
    buf[0] = FRAME_HEAD;
    buf[1] = CMD_ACK;
    buf[2] = 1;         // 数据长度
    buf[3] = status;    // 状态码
    
    // 计算CRC (命令+长度+数据)
    crc = CRC16_Calculate(&buf[1], 3);
    buf[4] = crc & 0xFF;
    buf[5] = (crc >> 8) & 0xFF;
    buf[6] = FRAME_TAIL;
    
    // 发送
    CDC_Transmit_FS(buf, 7);
}

/**
 * @brief  发送数据响应
 * @param  cmd: 命令码
 * @param  data: 数据指针
 * @param  len: 数据长度
 */
void Protocol_SendData(uint8_t cmd, uint8_t *data, uint8_t len)
{
    uint8_t buf[MAX_DATA_LEN + 6];
    uint16_t crc;
    uint16_t idx = 0;
    
    buf[idx++] = FRAME_HEAD;
    buf[idx++] = cmd;
    buf[idx++] = len;
    
    // 复制数据
    memcpy(&buf[idx], data, len);
    idx += len;
    
    // 计算CRC
    crc = CRC16_Calculate(&buf[1], len + 2);
    buf[idx++] = crc & 0xFF;
    buf[idx++] = (crc >> 8) & 0xFF;
    buf[idx++] = FRAME_TAIL;
    
    // 发送
    CDC_Transmit_FS(buf, idx);
}

/**
 * @brief  主动上报数据
 * @param  temp: 温度值
 * @param  voltage: 电压值
 * @param  current: 电流值
 */
void Protocol_ReportData(float temp, float voltage, float current)
{
    uint8_t data[12];
    
    memcpy(&data[0], &temp, 4);
    memcpy(&data[4], &voltage, 4);
    memcpy(&data[8], &current, 4);
    
    Protocol_SendData(CMD_DATA_REPORT, data, 12);
}

/**
 * @brief  处理接收到的帧
 * @param  frame: 帧指针
 */
static void ProcessFrame(Frame_t *frame)
{
    uint8_t data[16];
    float fval;
    
    switch (frame->cmd)
    {
        case CMD_GET_DEVICE_ID:
            // 返回设备ID
            strcpy((char*)data, "TM02-00000001");
            Protocol_SendData(CMD_GET_DEVICE_ID, data, 16);
            break;
            
        case CMD_GET_TEMPERATURE:
            // 返回温度值
            fval = APP_Temp_GetValue();
            Protocol_SendData(CMD_GET_TEMPERATURE, (uint8_t*)&fval, 4);
            break;
            
        case CMD_GET_VOLTAGE:
            // 返回电压值
            fval = APP_Temp_GetVoltage();
            Protocol_SendData(CMD_GET_VOLTAGE, (uint8_t*)&fval, 4);
            break;
            
        case CMD_SET_CURRENT_SRC:
            // 设置电流源
            if (frame->data[0] <= 1)
            {
                APP_Temp_SetCurrentSource(frame->data[0]);
                Protocol_SendAck(frame->cmd, STATUS_OK);
            }
            else
            {
                Protocol_SendAck(frame->cmd, STATUS_INVALID_PARAM);
            }
            break;
            
        case CMD_SET_CURRENT_ADJ_10:
            // 设置10μA调整值
            memcpy(&fval, frame->data, 4);
            APP_Param_SetCurrentAdj10(fval);
            Protocol_SendAck(frame->cmd, STATUS_OK);
            break;
            
        case CMD_SET_CURRENT_ADJ_17:
            // 设置17μA调整值
            memcpy(&fval, frame->data, 4);
            APP_Param_SetCurrentAdj17(fval);
            Protocol_SendAck(frame->cmd, STATUS_OK);
            break;
            
        case CMD_SET_4MA_TEMP:
            // 设置4mA温度点
            memcpy(&fval, frame->data, 4);
            APP_Param_Set4mATemp(fval);
            Protocol_SendAck(frame->cmd, STATUS_OK);
            break;
            
        case CMD_SET_20MA_TEMP:
            // 设置20mA温度点
            memcpy(&fval, frame->data, 4);
            APP_Param_Set20mATemp(fval);
            Protocol_SendAck(frame->cmd, STATUS_OK);
            break;
            
        case CMD_START_ACQ:
            // 开始采集
            APP_Temp_Start();
            Protocol_SendAck(frame->cmd, STATUS_OK);
            break;
            
        case CMD_STOP_ACQ:
            // 停止采集
            APP_Temp_Stop();
            Protocol_SendAck(frame->cmd, STATUS_OK);
            break;
            
        case CMD_SAVE_PARAM:
            // 保存参数
            if (APP_Param_Save() == 0)
                Protocol_SendAck(frame->cmd, STATUS_OK);
            else
                Protocol_SendAck(frame->cmd, STATUS_FLASH_ERROR);
            break;
            
        default:
            Protocol_SendAck(frame->cmd, STATUS_INVALID_CMD);
            break;
    }
}

/**
 * @brief  协议解析处理
 * @param  data: 接收数据指针
 * @param  len: 数据长度
 */
void Protocol_Process(uint8_t *data, uint16_t len)
{
    for (uint16_t i = 0; i < len; i++)
    {
        uint8_t byte = data[i];
        
        switch (parse_state)
        {
            case PARSE_HEAD:
                if (byte == FRAME_HEAD)
                {
                    rx_frame.head = byte;
                    parse_state = PARSE_CMD;
                }
                break;
                
            case PARSE_CMD:
                rx_frame.cmd = byte;
                parse_state = PARSE_LEN;
                break;
                
            case PARSE_LEN:
                rx_frame.len = byte;
                data_index = 0;
                if (byte > 0)
                    parse_state = PARSE_DATA;
                else
                    parse_state = PARSE_CRC_L;
                break;
                
            case PARSE_DATA:
                rx_frame.data[data_index++] = byte;
                if (data_index >= rx_frame.len)
                    parse_state = PARSE_CRC_L;
                break;
                
            case PARSE_CRC_L:
                rx_frame.crc = byte;
                parse_state = PARSE_CRC_H;
                break;
                
            case PARSE_CRC_H:
                rx_frame.crc |= ((uint16_t)byte << 8);
                parse_state = PARSE_TAIL;
                break;
                
            case PARSE_TAIL:
                if (byte == FRAME_TAIL)
                {
                    // 验证CRC
                    uint8_t crc_buf[MAX_DATA_LEN + 2];
                    crc_buf[0] = rx_frame.cmd;
                    crc_buf[1] = rx_frame.len;
                    memcpy(&crc_buf[2], rx_frame.data, rx_frame.len);
                    
                    uint16_t calc_crc = CRC16_Calculate(crc_buf, rx_frame.len + 2);
                    
                    if (calc_crc == rx_frame.crc)
                    {
                        // CRC正确，处理帧
                        ProcessFrame(&rx_frame);
                    }
                    else
                    {
                        // CRC错误
                        Protocol_SendAck(rx_frame.cmd, STATUS_CRC_ERROR);
                    }
                }
                parse_state = PARSE_HEAD;
                break;
        }
    }
}
```

---

## 六、LCD串口屏协议

### 6.1 淘晶驰串口屏指令格式

**指令格式：**
```
指令字符串 + 0xFF 0xFF 0xFF
```

### 6.2 常用指令

| 指令 | 说明 | 示例 |
|------|------|------|
| page | 切换页面 | `page 0` |
| t0.txt | 设置文本 | `t0.txt="Hello"` |
| n0.val | 设置数值 | `n0.val=123` |
| vis | 显示/隐藏 | `vis t0,1` |

### 6.3 LCD服务实现

```c
// svc_lcd.c

#include "svc_lcd.h"
#include "bsp_uart.h"
#include <stdio.h>
#include <string.h>

// 结束符
static const uint8_t lcd_end[] = {0xFF, 0xFF, 0xFF};

/**
 * @brief  发送LCD指令
 * @param  cmd: 指令字符串
 */
static void LCD_SendCmd(const char *cmd)
{
    BSP_UART_SendString(cmd);
    BSP_UART_Transmit((uint8_t*)lcd_end, 3);
}

/**
 * @brief  LCD初始化
 */
void SVC_LCD_Init(void)
{
    // 复位LCD
    LCD_SendCmd("rest");
    HAL_Delay(500);
    
    // 切换到主页面
    LCD_SendCmd("page 0");
}

/**
 * @brief  设置温度显示
 * @param  temp: 温度值 (℃)
 */
void SVC_LCD_SetTemperature(float temp)
{
    char buf[32];
    
    // 格式化温度字符串 (保留3位小数)
    sprintf(buf, "t_temp.txt=\"%.3f\"", temp);
    LCD_SendCmd(buf);
}

/**
 * @brief  设置电压显示
 * @param  voltage: 电压值 (mV)
 */
void SVC_LCD_SetVoltage(float voltage)
{
    char buf[32];
    
    sprintf(buf, "t_volt.txt=\"%.3f\"", voltage);
    LCD_SendCmd(buf);
}

/**
 * @brief  设置输出电流显示
 * @param  current: 电流值 (mA)
 */
void SVC_LCD_SetCurrent(float current)
{
    char buf[32];
    
    sprintf(buf, "t_curr.txt=\"%.2f\"", current);
    LCD_SendCmd(buf);
}

/**
 * @brief  设置状态显示
 * @param  status: 状态字符串
 */
void SVC_LCD_SetStatus(const char *status)
{
    char buf[64];
    
    sprintf(buf, "t_status.txt=\"%s\"", status);
    LCD_SendCmd(buf);
}

/**
 * @brief  设置电流源显示
 * @param  src: 0=10μA, 1=17μA
 */
void SVC_LCD_SetCurrentSource(uint8_t src)
{
    char buf[32];
    
    sprintf(buf, "t_src.txt=\"%s\"", src ? "17μA" : "10μA");
    LCD_SendCmd(buf);
}

/**
 * @brief  LCD更新 (周期调用)
 */
void SVC_LCD_Update(void)
{
    static uint32_t last_tick = 0;
    uint32_t tick = HAL_GetTick();
    
    // 1Hz更新
    if (tick - last_tick >= 1000)
    {
        last_tick = tick;
        
        // 更新温度
        SVC_LCD_SetTemperature(APP_Temp_GetValue());
        
        // 更新电压
        SVC_LCD_SetVoltage(APP_Temp_GetVoltage());
        
        // 更新电流
        SVC_LCD_SetCurrent(APP_Output_GetCurrent());
    }
}
```

---

*文档版本：V1.0*
*创建日期：2025年12月18日*

