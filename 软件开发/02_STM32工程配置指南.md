# STM32工程配置指南

## 文档信息

| 项目 | 内容 |
|------|------|
| 产品名称 | Ultra-TM02 超低温温度测量模块 |
| MCU型号 | STM32F411RET6 |
| 开发工具 | STM32CubeMX / Keil MDK |
| 版本 | V1.0 |
| 创建日期 | 2025年12月18日 |

---

## 一、STM32CubeMX配置

### 1.1 新建工程

1. 打开STM32CubeMX
2. 选择芯片：**STM32F411RET6**
3. 创建新工程

### 1.2 时钟配置

#### RCC设置

| 参数 | 配置 |
|------|------|
| HSE | Crystal/Ceramic Resonator (12MHz) |
| LSE | Disable |
| PLL Source | HSE |

#### 时钟树配置

```
HSE (12MHz)
    │
    └─→ PLL ─→ SYSCLK (100MHz)
              │
              ├─→ AHB (100MHz)
              │   ├─→ APB1 (50MHz)  → I2C, SPI2/3, USART2
              │   └─→ APB2 (100MHz) → SPI1, USART6, GPIO
              │
              └─→ USB (48MHz)
```

**PLL配置参数**：
| 参数 | 值 |
|------|-----|
| PLLM | 6 |
| PLLN | 100 |
| PLLP | 2 |
| PLLQ | 4 |

### 1.3 GPIO配置

#### 输出引脚

| 引脚 | 功能 | 模式 | 初始值 |
|------|------|------|--------|
| PA4 | ADC1_CS | Output Push-Pull | High |
| PA8 | DAC1_CS | Output Push-Pull | High |
| PA9 | DAC2_CS | Output Push-Pull | High |
| PA10 | DAC1_LOAD | Output Push-Pull | High |
| PB0 | DAC2_LOAD | Output Push-Pull | High |
| PC13 | LED1 | Output Push-Pull | High |

#### 输入引脚

| 引脚 | 功能 | 模式 |
|------|------|------|
| PA0 | ADC_DRDY | Input (External Interrupt) |

### 1.4 SPI配置

#### SPI1 (ADC/DAC通讯)

| 参数 | 配置 |
|------|------|
| Mode | Full-Duplex Master |
| Hardware NSS | Disable |
| Frame Format | Motorola |
| Data Size | 8 bits |
| First Bit | MSB First |
| Prescaler | 8 (PCLK2/8 = 12.5MHz) |
| CPOL | High |
| CPHA | 2 Edge |
| CRC | Disable |

**引脚分配**：
| 引脚 | 功能 |
|------|------|
| PA5 | SPI1_SCK |
| PA6 | SPI1_MISO |
| PA7 | SPI1_MOSI |

### 1.5 UART配置

#### USART6 (LCD串口屏)

| 参数 | 配置 |
|------|------|
| Mode | Asynchronous |
| Baud Rate | 115200 |
| Word Length | 8 bits |
| Parity | None |
| Stop Bits | 1 |
| Data Direction | Receive and Transmit |
| Over Sampling | 16 |

**引脚分配**：
| 引脚 | 功能 |
|------|------|
| PC6 | USART6_TX |
| PC7 | USART6_RX |

**DMA配置**（可选）：
| DMA | Stream | Channel | Direction |
|-----|--------|---------|-----------|
| DMA2 | Stream6 | Channel5 | TX |
| DMA2 | Stream1 | Channel5 | RX |

### 1.6 USB配置

#### USB OTG FS

| 参数 | 配置 |
|------|------|
| Mode | Device Only |
| Device Class | CDC (Virtual COM Port) |
| Speed | Full Speed |

**引脚分配**：
| 引脚 | 功能 |
|------|------|
| PA11 | USB_OTG_FS_DM |
| PA12 | USB_OTG_FS_DP |

### 1.7 中断配置

#### NVIC设置

| 中断源 | 优先级 | 状态 |
|--------|--------|------|
| EXTI0 | 5 | Enable (ADC_DRDY) |
| SPI1 | 6 | Enable |
| USART6 | 7 | Enable |
| USB_OTG_FS | 8 | Enable |
| SysTick | 0 | Enable |

### 1.8 工程生成

#### 工程设置

| 参数 | 配置 |
|------|------|
| Project Name | Ultra_TM02 |
| Project Location | 自定义路径 |
| Toolchain/IDE | MDK-ARM V5 |
| Min Heap Size | 0x400 |
| Min Stack Size | 0x800 |

#### 代码生成选项

- ☑ Generate peripheral initialization as a pair of '.c/.h' files
- ☑ Keep User Code when re-generating
- ☑ Delete previously generated files when not re-generated

---

## 二、Keil MDK工程配置

### 2.1 工程结构

```
Ultra_TM02/
├── MDK-ARM/
│   └── Ultra_TM02.uvprojx      # Keil工程文件
├── Core/
│   ├── Inc/
│   └── Src/
├── Drivers/
│   ├── STM32F4xx_HAL_Driver/
│   └── CMSIS/
├── Middlewares/
│   └── ST/
│       └── STM32_USB_Device_Library/
└── USB_DEVICE/
    ├── App/
    └── Target/
```

### 2.2 编译器设置

| 参数 | 配置 |
|------|------|
| ARM Compiler | Version 6 |
| Optimization | -O2 |
| Debug Format | DWARF |
| C99 Mode | Enable |

### 2.3 链接器设置

| 参数 | 值 |
|------|-----|
| R/O Base | 0x08000000 |
| R/W Base | 0x20000000 |
| ROM Size | 0x80000 (512KB) |
| RAM Size | 0x20000 (128KB) |

### 2.4 调试器配置

#### ST-Link Debugger

| 参数 | 配置 |
|------|------|
| Debug Adapter | ST-Link Debugger |
| Port | SW |
| Max Clock | 4MHz |
| Reset | Autodetect |

#### Flash Download

| 参数 | 配置 |
|------|------|
| Flash Algorithm | STM32F4xx 512KB Flash |
| Programming Algorithm | 0x08000000 - 0x0807FFFF |
| RAM for Algorithm | 0x20000000 |

---

## 三、外设初始化代码

### 3.1 GPIO初始化

```c
// bsp_gpio.c

#include "bsp_gpio.h"

// GPIO引脚定义
#define ADC1_CS_PIN         GPIO_PIN_4
#define ADC1_CS_PORT        GPIOA
#define DAC1_CS_PIN         GPIO_PIN_8
#define DAC1_CS_PORT        GPIOA
#define DAC2_CS_PIN         GPIO_PIN_9
#define DAC2_CS_PORT        GPIOA
#define DAC1_LOAD_PIN       GPIO_PIN_10
#define DAC1_LOAD_PORT      GPIOA
#define DAC2_LOAD_PIN       GPIO_PIN_0
#define DAC2_LOAD_PORT      GPIOB
#define LED1_PIN            GPIO_PIN_13
#define LED1_PORT           GPIOC

/**
 * @brief  GPIO初始化
 * @param  无
 * @retval 无
 */
void BSP_GPIO_Init(void)
{
    GPIO_InitTypeDef GPIO_InitStruct = {0};
    
    // 使能GPIO时钟
    __HAL_RCC_GPIOA_CLK_ENABLE();
    __HAL_RCC_GPIOB_CLK_ENABLE();
    __HAL_RCC_GPIOC_CLK_ENABLE();
    
    // 配置输出引脚
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
    
    // ADC1_CS
    GPIO_InitStruct.Pin = ADC1_CS_PIN;
    HAL_GPIO_Init(ADC1_CS_PORT, &GPIO_InitStruct);
    HAL_GPIO_WritePin(ADC1_CS_PORT, ADC1_CS_PIN, GPIO_PIN_SET);
    
    // DAC1_CS
    GPIO_InitStruct.Pin = DAC1_CS_PIN;
    HAL_GPIO_Init(DAC1_CS_PORT, &GPIO_InitStruct);
    HAL_GPIO_WritePin(DAC1_CS_PORT, DAC1_CS_PIN, GPIO_PIN_SET);
    
    // DAC2_CS
    GPIO_InitStruct.Pin = DAC2_CS_PIN;
    HAL_GPIO_Init(DAC2_CS_PORT, &GPIO_InitStruct);
    HAL_GPIO_WritePin(DAC2_CS_PORT, DAC2_CS_PIN, GPIO_PIN_SET);
    
    // DAC1_LOAD
    GPIO_InitStruct.Pin = DAC1_LOAD_PIN;
    HAL_GPIO_Init(DAC1_LOAD_PORT, &GPIO_InitStruct);
    HAL_GPIO_WritePin(DAC1_LOAD_PORT, DAC1_LOAD_PIN, GPIO_PIN_SET);
    
    // DAC2_LOAD
    GPIO_InitStruct.Pin = DAC2_LOAD_PIN;
    HAL_GPIO_Init(DAC2_LOAD_PORT, &GPIO_InitStruct);
    HAL_GPIO_WritePin(DAC2_LOAD_PORT, DAC2_LOAD_PIN, GPIO_PIN_SET);
    
    // LED1
    GPIO_InitStruct.Pin = LED1_PIN;
    HAL_GPIO_Init(LED1_PORT, &GPIO_InitStruct);
    HAL_GPIO_WritePin(LED1_PORT, LED1_PIN, GPIO_PIN_SET);
}

/**
 * @brief  设置ADC片选
 * @param  state: 0=选中, 1=取消
 */
void BSP_ADC_CS(uint8_t state)
{
    HAL_GPIO_WritePin(ADC1_CS_PORT, ADC1_CS_PIN, 
                      state ? GPIO_PIN_SET : GPIO_PIN_RESET);
}

/**
 * @brief  设置DAC1片选
 * @param  state: 0=选中, 1=取消
 */
void BSP_DAC1_CS(uint8_t state)
{
    HAL_GPIO_WritePin(DAC1_CS_PORT, DAC1_CS_PIN, 
                      state ? GPIO_PIN_SET : GPIO_PIN_RESET);
}

/**
 * @brief  设置DAC2片选
 * @param  state: 0=选中, 1=取消
 */
void BSP_DAC2_CS(uint8_t state)
{
    HAL_GPIO_WritePin(DAC2_CS_PORT, DAC2_CS_PIN, 
                      state ? GPIO_PIN_SET : GPIO_PIN_RESET);
}

/**
 * @brief  LED控制
 * @param  state: 0=灭, 1=亮
 */
void BSP_LED_Set(uint8_t state)
{
    HAL_GPIO_WritePin(LED1_PORT, LED1_PIN, 
                      state ? GPIO_PIN_RESET : GPIO_PIN_SET);
}

/**
 * @brief  LED翻转
 */
void BSP_LED_Toggle(void)
{
    HAL_GPIO_TogglePin(LED1_PORT, LED1_PIN);
}
```

### 3.2 SPI初始化

```c
// bsp_spi.c

#include "bsp_spi.h"

SPI_HandleTypeDef hspi1;

/**
 * @brief  SPI1初始化
 * @param  无
 * @retval 无
 */
void BSP_SPI_Init(void)
{
    // SPI1配置
    hspi1.Instance = SPI1;
    hspi1.Init.Mode = SPI_MODE_MASTER;
    hspi1.Init.Direction = SPI_DIRECTION_2LINES;
    hspi1.Init.DataSize = SPI_DATASIZE_8BIT;
    hspi1.Init.CLKPolarity = SPI_POLARITY_HIGH;
    hspi1.Init.CLKPhase = SPI_PHASE_2EDGE;
    hspi1.Init.NSS = SPI_NSS_SOFT;
    hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_8;
    hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
    hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
    hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
    
    if (HAL_SPI_Init(&hspi1) != HAL_OK)
    {
        Error_Handler();
    }
}

/**
 * @brief  SPI收发一个字节
 * @param  tx_data: 发送数据
 * @retval 接收数据
 */
uint8_t BSP_SPI_TransmitReceive(uint8_t tx_data)
{
    uint8_t rx_data = 0;
    HAL_SPI_TransmitReceive(&hspi1, &tx_data, &rx_data, 1, 100);
    return rx_data;
}

/**
 * @brief  SPI发送数据
 * @param  data: 数据指针
 * @param  len: 数据长度
 * @retval HAL状态
 */
HAL_StatusTypeDef BSP_SPI_Transmit(uint8_t *data, uint16_t len)
{
    return HAL_SPI_Transmit(&hspi1, data, len, 100);
}

/**
 * @brief  SPI接收数据
 * @param  data: 数据指针
 * @param  len: 数据长度
 * @retval HAL状态
 */
HAL_StatusTypeDef BSP_SPI_Receive(uint8_t *data, uint16_t len)
{
    return HAL_SPI_Receive(&hspi1, data, len, 100);
}
```

### 3.3 UART初始化

```c
// bsp_uart.c

#include "bsp_uart.h"

UART_HandleTypeDef huart6;

// 接收缓冲区
#define RX_BUFFER_SIZE  256
static uint8_t rx_buffer[RX_BUFFER_SIZE];
static volatile uint16_t rx_head = 0;
static volatile uint16_t rx_tail = 0;

/**
 * @brief  UART6初始化 (LCD串口屏)
 * @param  无
 * @retval 无
 */
void BSP_UART_Init(void)
{
    huart6.Instance = USART6;
    huart6.Init.BaudRate = 115200;
    huart6.Init.WordLength = UART_WORDLENGTH_8B;
    huart6.Init.StopBits = UART_STOPBITS_1;
    huart6.Init.Parity = UART_PARITY_NONE;
    huart6.Init.Mode = UART_MODE_TX_RX;
    huart6.Init.HwFlowCtl = UART_HWCONTROL_NONE;
    huart6.Init.OverSampling = UART_OVERSAMPLING_16;
    
    if (HAL_UART_Init(&huart6) != HAL_OK)
    {
        Error_Handler();
    }
    
    // 使能接收中断
    HAL_UART_Receive_IT(&huart6, &rx_buffer[0], 1);
}

/**
 * @brief  UART发送数据
 * @param  data: 数据指针
 * @param  len: 数据长度
 * @retval HAL状态
 */
HAL_StatusTypeDef BSP_UART_Transmit(uint8_t *data, uint16_t len)
{
    return HAL_UART_Transmit(&huart6, data, len, 1000);
}

/**
 * @brief  UART发送字符串
 * @param  str: 字符串指针
 * @retval 无
 */
void BSP_UART_SendString(const char *str)
{
    HAL_UART_Transmit(&huart6, (uint8_t *)str, strlen(str), 1000);
}

/**
 * @brief  检查是否有接收数据
 * @retval 可用数据字节数
 */
uint16_t BSP_UART_Available(void)
{
    return (rx_head - rx_tail + RX_BUFFER_SIZE) % RX_BUFFER_SIZE;
}

/**
 * @brief  读取一个字节
 * @retval 数据 (-1表示无数据)
 */
int BSP_UART_Read(void)
{
    if (rx_head == rx_tail) return -1;
    uint8_t data = rx_buffer[rx_tail];
    rx_tail = (rx_tail + 1) % RX_BUFFER_SIZE;
    return data;
}

/**
 * @brief  UART接收中断回调
 * @param  huart: UART句柄
 * @retval 无
 */
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
    if (huart->Instance == USART6)
    {
        rx_head = (rx_head + 1) % RX_BUFFER_SIZE;
        HAL_UART_Receive_IT(&huart6, &rx_buffer[rx_head], 1);
    }
}
```

---

## 四、调试技巧

### 4.1 SWD调试

#### H1接口引脚定义

| H1引脚 | 信号 | ST-Link V2 |
|--------|------|------------|
| 1 | 3V3 | 3.3V (可选) |
| 2 | GND | GND |
| 3 | SWDIO | SWDIO |
| 4 | SWCLK | SWCLK |

#### 连接步骤

1. 按上表连接ST-Link V2到主板H1接口
2. 确认SWCLK、SWDIO、GND连接正确（最少需连接这3根线）
3. Keil中点击"Options for Target" → "Debug"
4. 选择"ST-Link Debugger" → "Settings"
5. 确认检测到芯片

> **注意**：H1引脚1在左侧，引脚4在右侧（面向接口看）

### 4.2 常见问题

| 问题 | 原因 | 解决方法 |
|------|------|----------|
| 无法连接芯片 | SWD接线错误 | 检查接线，确认SWCLK、SWDIO |
| Flash下载失败 | 芯片被锁定 | 使用ST-Link Utility解锁 |
| 程序不运行 | 时钟配置错误 | 检查HSE晶振、PLL配置 |
| USB无法识别 | 48MHz时钟错误 | 检查PLLQ配置 |

### 4.3 串口调试

可使用printf重定向到USB CDC或UART：

```c
// 重定向printf到USB CDC
int fputc(int ch, FILE *f)
{
    CDC_Transmit_FS((uint8_t *)&ch, 1);
    return ch;
}

// 或重定向到UART
int fputc(int ch, FILE *f)
{
    HAL_UART_Transmit(&huart6, (uint8_t *)&ch, 1, 10);
    return ch;
}
```

---

*文档版本：V1.0*
*创建日期：2025年12月18日*

